<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #333;
      margin: 0;
      font-family: Arial, sans-serif;
      color: #fff;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

#scoreboard {
  font-size: 1.2em;
  margin-bottom: 10px; /* Adiciona espa√ßo entre a pontua√ß√£o e o jogo */
}

#controls {
  display: flex;
  justify-content: center;
  margin-top: 10px; /* Adiciona espa√ßo entre o jogo e os bot√µes */
}


#tetris {
  width: 180px; /* Reduz a largura */
  height: 360px; /* Reduz a altura */
  border: 2px solid #fff;
  background-color: #111;
  border-radius: 15px;
}


    #controls {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }

button {
  width: 50px; /* Defina a largura */
  height: 50px; /* Defina a altura igual √† largura para tornar o bot√£o redondo */
  background-color: #555;
  color: #fff;
  border: none;
  border-radius: 50%; /* Torna o bot√£o redondo */
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center; /* Centraliza o texto */
  margin: 5px;
}

button:active {
  background-color: #777;
}


@media only screen and (min-width: 600px) {
  #tetris {
    width: 270px; /* Ajuste conforme necess√°rio */
    height: 540px;
  }
}

@media only screen and (max-width: 599px) {
  #tetris {
    width: 180px;
    height: 360px;
  }
}

  </style>
</head>
<body>
  <div id="game-container">
    <div id="scoreboard">Pontua√ß√£o: <span id="score">0</span></div>
    <canvas id="tetris" width="180" height="360"></canvas>
    <div id="controls">
      <button id="left">‚óÑ</button>
      <button id="down">‚ñº</button>
      <button id="right">‚ñ∫</button>
      <button id="rotate">‚ü≥</button>
      <button id="pause">‚è∏</button>
      <button id="mute">üîá</button> <!-- Bot√£o para desativar o som -->

    </div>
  </div>

  <script>
    const canvas = document.getElementById("tetris");
    const context = canvas.getContext("2d");
    const scale = canvas.width / 10;
    const rows = 20;
    const cols = 10;

    let isPaused = false;
    let score = 0;
    context.scale(scale, scale);

    const tetrominoes = "IJLOSTZ";
const colors = {
  I: "#00f0f0",  // Ciano
  J: "#0000f0",  // Azul
  L: "#f0a000",  // Laranja
  O: "#f0f000",  // Amarelo
  S: "#00f000",  // Verde
  T: "#a000f0",  // Roxo
  Z: "#f00000",  // Vermelho
};


    function createPiece(type) {
      switch (type) {
        case "T": return [[0, 1, 0], [1, 1, 1]];
        case "O": return [[1, 1], [1, 1]];
        case "L": return [[0, 0, 1], [1, 1, 1]];
        case "J": return [[1, 0, 0], [1, 1, 1]];
        case "I": return [[1, 1, 1, 1]];
        case "S": return [[0, 1, 1], [1, 1, 0]];
        case "Z": return [[1, 1, 0], [0, 1, 1]];
      }
    }

    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    const arena = createMatrix(cols, rows);

    function rotate(matrix) {
      return matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
    }

    function collide(arena, player) {
      const [m, o] = [player.matrix, player.pos];
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (m[y][x] !== 0 &&
              (arena[y + o.y] &&
               arena[y + o.y][x + o.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    

function merge(arena, player) {
  player.matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        arena[y + player.pos.y][x + player.pos.x] = { value, color: player.color }; // Adiciona a cor ao objeto da pe√ßa
      }
    });
  });
}
function drawRoundedRect(x, y, width, height, radius, fillColor, strokeColor) {
  context.beginPath();
  context.moveTo(x + radius, y);
  context.lineTo(x + width - radius, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius);
  context.lineTo(x + width, y + height - radius);
  context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  context.lineTo(x + radius, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius);
  context.lineTo(x, y + radius);
  context.quadraticCurveTo(x, y, x + radius, y);
  context.closePath();

  // Preencher com a cor correta
  context.fillStyle = fillColor;  // Atribui a cor correta antes de preencher
  context.fill();

  // Adiciona borda escura
  context.strokeStyle = strokeColor;
  context.lineWidth = 0.1;
  context.stroke();
}



function drawMatrix(matrix, offset) {
  matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        let fillColor, strokeColor = "#000";

        if (typeof value === 'object') {
          fillColor = value.color;  // Usa a cor da pe√ßa j√° definida
        } else {
          fillColor = colors[value];
        }

        drawRoundedRect(
          x + offset.x, 
          y + offset.y, 
          1, 1,        
          0.3,         
          fillColor,   
          strokeColor  
        );
      }
    });
  });
}





function draw() {
  context.fillStyle = "#808080"; // Cor atual do fundo da arena
  context.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
  drawMatrix(arena, { x: 0, y: 0 });
  drawMatrix(player.matrix, player.pos);
}

const dropSound = new Audio('drop.mp3');

function drop() {
   if (isPaused) return;
   player.pos.y++;
   if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      dropSound.play(); // Som ao soltar a pe√ßa no lugar
      resetPlayer();
      arenaSweep();
      updateScore();
   }
   dropCounter = 0;
}


function resetPlayer() {
  const pieceType = tetrominoes[(Math.random() * tetrominoes.length) | 0];
  player.matrix = createPiece(pieceType);
  player.color = colors[pieceType];  // Atribui a cor da pe√ßa com base no tipo gerado
  player.pos.y = 0;
  player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
  
  // Checa se a nova pe√ßa colide imediatamente
  if (collide(arena, player)) {
    arena.forEach(row => row.fill(0));  // Limpa a arena se houver uma colis√£o no in√≠cio
    score = 0;  // Reseta a pontua√ß√£o (opcional)
    updateScore();  // Atualiza o display da pontua√ß√£o
  }
}

    const lineClearSound = new Audio('line-clear.mp3'); // Som ao limpar linha

    function arenaSweep() {
      let rowCount = 1;
      outer: for (let y = arena.length - 1; y >= 0; y--) {
        for (let x = 0; x < arena[y].length; x++) {
          if (arena[y][x] === 0) continue outer;
        }
// Efeito de flash: muda a cor da linha antes de remover
       arena[y].forEach((_, i) => arena[y][i] = { value: 1, color: '#fff' }); // Coloca cor branca (flash)
       draw(); // Atualiza o visual
       
       setTimeout(() => {
           arena.splice(y, 1);
           arena.unshift(new Array(cols).fill(0));
       }, 100);  // Remove a linha ap√≥s 100ms
       
       score += rowCount * 10;
       rowCount *= 2;
       lineClearSound.play(); // Toca o som ao completar a linha
   }
}
    function updateScore() {
      document.getElementById("score").innerText = score;
    }

    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let isFastDropping = false;

function update(time = 0) {
  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;

  if (isFastDropping) {
    if (dropCounter > 50) {  // Ajuste o intervalo para queda r√°pida (50ms)
      drop();
    }
  } else {
    if (dropCounter > dropInterval) {
      drop();
    }
  }

  draw();
  requestAnimationFrame(update);
}


document.addEventListener("keydown", event => {
  if (event.key === "ArrowLeft") {
    playerMove(-1);
  } else if (event.key === "ArrowRight") {
    playerMove(1);
  } else if (event.key === "ArrowDown") {
    isFastDropping = true;  // Inicia queda r√°pida
  } else if (event.key === "ArrowUp") {
    rotatePlayer();
  } else if (event.key === "p") {
    togglePause();
  }
});

document.addEventListener("keyup", event => {
  if (event.key === "ArrowDown") {
    isFastDropping = false;  // Para queda r√°pida ao soltar a tecla
  }
});


const moveSound = new Audio('move.mp3');
const rotateSound = new Audio('rotate.mp3');

function playerMove(offset) {
   player.pos.x += offset;
   if (collide(arena, player)) {
      player.pos.x -= offset;
   } else {
      moveSound.play(); // Toca o som ao mover
   }
}

function rotatePlayer() {
   rotateSound.play(); // Toca o som ao girar
   const pos = player.pos.x;
   let offset = 1;
   player.matrix = rotate(player.matrix);
   while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
         player.matrix = rotate(player.matrix);
         player.pos.x = pos;
         return;
      }
   }
}


    function drawGhost() {
   const ghostPlayer = { ...player, pos: { ...player.pos } };
   while (!collide(arena, ghostPlayer)) {
      ghostPlayer.pos.y++;
   }
   ghostPlayer.pos.y--;
   drawMatrix(ghostPlayer.matrix, ghostPlayer.pos, 'rgba(255, 255, 255, 0.3)'); // Cor mais clara
}

function draw() {
   context.fillStyle = "#808080"; 
   context.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
   
   // Desenha a sombra antes da pe√ßa
   drawGhost(); 
   drawMatrix(arena, { x: 0, y: 0 });
   drawMatrix(player.matrix, player.pos);
}



    function togglePause() {
      isPaused = !isPaused;
      document.getElementById("pause").innerText = isPaused ? "‚ñ∂" : "‚è∏";
    }



  


    // Movimenta√ß√£o cont√≠nua para o bot√£o de mover para esquerda
    document.getElementById("left").addEventListener("mousedown", () => {
      playerMove(-1); // Mover uma vez ao clicar
      moveInterval = setInterval(() => playerMove(-1), 150); // Mover continuamente ao segurar
    });
    document.getElementById("left").addEventListener("mouseup", () => clearInterval(moveInterval)); // Parar ao soltar o bot√£o
    document.getElementById("left").addEventListener("mouseleave", () => clearInterval(moveInterval)); // Parar ao sair do bot√£o

    // Movimenta√ß√£o cont√≠nua para o bot√£o de mover para direita
    document.getElementById("right").addEventListener("mousedown", () => {
      playerMove(1); // Mover uma vez ao clicar
      moveInterval = setInterval(() => playerMove(1), 150); // Mover continuamente ao segurar
    });
    document.getElementById("right").addEventListener("mouseup", () => clearInterval(moveInterval)); // Parar ao soltar o bot√£o
    document.getElementById("right").addEventListener("mouseleave", () => clearInterval(moveInterval)); // Parar ao sair do bot√£o

    // Mant√©m o comportamento existente de movimenta√ß√£o para baixo
    document.getElementById("down").addEventListener("mousedown", () => {
      isFastDropping = true;  // Inicia queda r√°pida ao pressionar o bot√£o
    });
    document.getElementById("down").addEventListener("mouseup", () => {
      isFastDropping = false;  // Para queda r√°pida ao soltar o bot√£o
    });

    // Bot√£o para girar a pe√ßa
    document.getElementById("rotate").addEventListener("click", rotatePlayer); // Recolocar o evento de click para rota√ß√£o

    // Bot√£o para pausar o jogo
    document.getElementById("pause").addEventListener("click", togglePause); // Evento de click para pausar/despausar



    const player = { pos: { x: 0, y: 0 }, matrix: null, color: null };
    resetPlayer();
    update();

    
  </script>
</body>
</html>
