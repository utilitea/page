<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #333;
      margin: 0;
      font-family: Arial, sans-serif;
      color: #fff;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

#scoreboard {
  font-size: 1.2em;
  margin-bottom: 10px; /* Adiciona espaço entre a pontuação e o jogo */
}

#controls {
  display: flex;
  justify-content: center;
  margin-top: 10px; /* Adiciona espaço entre o jogo e os botões */
}


#tetris {
  width: 180px; /* Reduz a largura */
  height: 360px; /* Reduz a altura */
  border: 2px solid #fff;
  background-color: #111;
  border-radius: 15px;
}


    #controls {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }

button {
  width: 50px; /* Defina a largura */
  height: 50px; /* Defina a altura igual à largura para tornar o botão redondo */
  background-color: #555;
  color: #fff;
  border: none;
  border-radius: 50%; /* Torna o botão redondo */
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center; /* Centraliza o texto */
  margin: 5px;
}

button:active {
  background-color: #777;
}


@media only screen and (min-width: 600px) {
  #tetris {
    width: 270px; /* Ajuste conforme necessário */
    height: 540px;
  }
}

@media only screen and (max-width: 599px) {
  #tetris {
    width: 180px;
    height: 360px;
  }
}

  </style>
</head>
<body>
  <div id="game-container">
    <div id="scoreboard">Pontuação: <span id="score">0</span></div>
    <canvas id="tetris" width="180" height="360"></canvas>
    <div id="controls">
      <button id="left">◄</button>
      <button id="down">▼</button>
      <button id="right">►</button>
      <button id="rotate">⟳</button>
      <button id="pause">⏸</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("tetris");
    const context = canvas.getContext("2d");
    const scale = canvas.width / 10;
    const rows = 20;
    const cols = 10;

    let isPaused = false;
    let score = 0;
    context.scale(scale, scale);

    const tetrominoes = "IJLOSTZ";
const colors = {
  I: "#00f0f0",  // Ciano
  J: "#0000f0",  // Azul
  L: "#f0a000",  // Laranja
  O: "#f0f000",  // Amarelo
  S: "#00f000",  // Verde
  T: "#a000f0",  // Roxo
  Z: "#f00000",  // Vermelho
};


    function createPiece(type) {
      switch (type) {
        case "T": return [[0, 1, 0], [1, 1, 1]];
        case "O": return [[1, 1], [1, 1]];
        case "L": return [[0, 0, 1], [1, 1, 1]];
        case "J": return [[1, 0, 0], [1, 1, 1]];
        case "I": return [[1, 1, 1, 1]];
        case "S": return [[0, 1, 1], [1, 1, 0]];
        case "Z": return [[1, 1, 0], [0, 1, 1]];
      }
    }

    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    const arena = createMatrix(cols, rows);

    function rotate(matrix) {
      return matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
    }

    function collide(arena, player) {
      const [m, o] = [player.matrix, player.pos];
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (m[y][x] !== 0 &&
              (arena[y + o.y] &&
               arena[y + o.y][x + o.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

function merge(arena, player) {
  player.matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = player.color; // Salva a cor da peça
    });
  });
}
function drawRoundedRect(x, y, width, height, radius, fillColor, strokeColor) {
  context.beginPath();
  context.moveTo(x + radius, y);
  context.lineTo(x + width - radius, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius);
  context.lineTo(x + width, y + height - radius);
  context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  context.lineTo(x + radius, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius);
  context.lineTo(x, y + radius);
  context.quadraticCurveTo(x, y, x + radius, y);
  context.closePath();

  // Preencher com a cor correta
  context.fillStyle = fillColor;  // Atribui a cor correta antes de preencher
  context.fill();

  // Adiciona borda escura
  context.strokeStyle = strokeColor;
  context.lineWidth = 0.1;
  context.stroke();
}



function drawMatrix(matrix, offset) {
  matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        let fillColor = colors[value];  // Atribuir a cor correta à peça
        let strokeColor = "#000";       // Cor da borda (mais escura)

        // Desenhar cada bloco com bordas arredondadas e preenchimento colorido
        drawRoundedRect(
          x + offset.x, 
          y + offset.y, 
          1, 1,        // Dimensões da peça
          0.3,         // Raio das bordas arredondadas
          fillColor,   // Cor da peça
          strokeColor  // Borda escura
        );
      }
    });
  });
}



    function draw() {
      context.fillStyle = "#808080"; // Cor atual do fundo da arena
      context.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
      drawMatrix(arena, { x: 0, y: 0 });
      drawMatrix(player.matrix, player.pos, player.color);
    }

    function drop() {
      if (isPaused) return;
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        resetPlayer();
        arenaSweep();
        updateScore();
      }
      dropCounter = 0;
    }

    function resetPlayer() {
      const pieceType = tetrominoes[(Math.random() * tetrominoes.length) | 0];
      player.matrix = createPiece(pieceType);
      player.color = colors[pieceType];
      player.pos.y = 0;
      player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
      if (collide(arena, player)) arena.forEach(row => row.fill(0));
    }

    function arenaSweep() {
      let rowCount = 1;
      outer: for (let y = arena.length - 1; y >= 0; y--) {
        for (let x = 0; x < arena[y].length; x++) {
          if (arena[y][x] === 0) continue outer;
        }
        arena.splice(y, 1);
        arena.unshift(new Array(cols).fill(0));
        score += rowCount * 10;
        rowCount *= 2;
      }
    }

    function updateScore() {
      document.getElementById("score").innerText = score;
    }

    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let isFastDropping = false;

function update(time = 0) {
  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;

  if (isFastDropping) {
    if (dropCounter > 50) {  // Ajuste o intervalo para queda rápida (50ms)
      drop();
    }
  } else {
    if (dropCounter > dropInterval) {
      drop();
    }
  }

  draw();
  requestAnimationFrame(update);
}


document.addEventListener("keydown", event => {
  if (event.key === "ArrowLeft") {
    playerMove(-1);
  } else if (event.key === "ArrowRight") {
    playerMove(1);
  } else if (event.key === "ArrowDown") {
    isFastDropping = true;  // Inicia queda rápida
  } else if (event.key === "ArrowUp") {
    rotatePlayer();
  } else if (event.key === "p") {
    togglePause();
  }
});

document.addEventListener("keyup", event => {
  if (event.key === "ArrowDown") {
    isFastDropping = false;  // Para queda rápida ao soltar a tecla
  }
});


    function playerMove(offset) {
      player.pos.x += offset;
      if (collide(arena, player)) player.pos.x -= offset;
    }

    function rotatePlayer() {
      const pos = player.pos.x;
      let offset = 1;
      player.matrix = rotate(player.matrix);
      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
          player.matrix = rotate(player.matrix);
          player.pos.x = pos;
          return;
        }
      }
    }

    function togglePause() {
      isPaused = !isPaused;
      document.getElementById("pause").innerText = isPaused ? "▶" : "⏸";
    }

    document.getElementById("left").addEventListener("click", () => playerMove(-1));
    document.getElementById("right").addEventListener("click", () => playerMove(1));
    document.getElementById("rotate").addEventListener("click", rotatePlayer);
    document.getElementById("down").addEventListener("click", drop);
    document.getElementById("pause").addEventListener("click", togglePause);
    
    document.getElementById("down").addEventListener("mousedown", () => {
  isFastDropping = true;  // Inicia queda rápida ao pressionar o botão
});

document.getElementById("down").addEventListener("mouseup", () => {
  isFastDropping = false;  // Para queda rápida ao soltar o botão
});


    const player = { pos: { x: 0, y: 0 }, matrix: null, color: null };
    resetPlayer();
    update();
  </script>
</body>
</html>
